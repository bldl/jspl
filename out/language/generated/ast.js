/******************************************************************************
 * This file was generated by langium-cli 2.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/
import { AbstractAstReflection } from 'langium';
export const JavaScriptPropositionalLaboratoryFormatTerminals = {
    BOOLEAN: /True|False/,
    ID: /[_a-zA-Z][\w_]*/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};
export const PropositionalExpression = 'PropositionalExpression';
export function isPropositionalExpression(item) {
    return reflection.isInstance(item, PropositionalExpression);
}
export const Referenceable = 'Referenceable';
export function isReferenceable(item) {
    return reflection.isInstance(item, Referenceable);
}
export const AndExpression = 'AndExpression';
export function isAndExpression(item) {
    return reflection.isInstance(item, AndExpression);
}
export const Concern = 'Concern';
export function isConcern(item) {
    return reflection.isInstance(item, Concern);
}
export const Condition = 'Condition';
export function isCondition(item) {
    return reflection.isInstance(item, Condition);
}
export const DisableClause = 'DisableClause';
export function isDisableClause(item) {
    return reflection.isInstance(item, DisableClause);
}
export const DisableStatement = 'DisableStatement';
export function isDisableStatement(item) {
    return reflection.isInstance(item, DisableStatement);
}
export const FormattedString = 'FormattedString';
export function isFormattedString(item) {
    return reflection.isInstance(item, FormattedString);
}
export const Group = 'Group';
export function isGroup(item) {
    return reflection.isInstance(item, Group);
}
export const LaboratoryInformation = 'LaboratoryInformation';
export function isLaboratoryInformation(item) {
    return reflection.isInstance(item, LaboratoryInformation);
}
export const Model = 'Model';
export function isModel(item) {
    return reflection.isInstance(item, Model);
}
export const Negation = 'Negation';
export function isNegation(item) {
    return reflection.isInstance(item, Negation);
}
export const OrExpression = 'OrExpression';
export function isOrExpression(item) {
    return reflection.isInstance(item, OrExpression);
}
export const Proposition = 'Proposition';
export function isProposition(item) {
    return reflection.isInstance(item, Proposition);
}
export const RaisingConcern = 'RaisingConcern';
export function isRaisingConcern(item) {
    return reflection.isInstance(item, RaisingConcern);
}
export const Statement = 'Statement';
export function isStatement(item) {
    return reflection.isInstance(item, Statement);
}
export const ValueClause = 'ValueClause';
export function isValueClause(item) {
    return reflection.isInstance(item, ValueClause);
}
export const WhenCondition = 'WhenCondition';
export function isWhenCondition(item) {
    return reflection.isInstance(item, WhenCondition);
}
export class JavaScriptPropositionalLaboratoryFormatAstReflection extends AbstractAstReflection {
    getAllTypes() {
        return ['AndExpression', 'Concern', 'Condition', 'DisableClause', 'DisableStatement', 'FormattedString', 'Group', 'LaboratoryInformation', 'Model', 'Negation', 'OrExpression', 'Proposition', 'PropositionalExpression', 'RaisingConcern', 'Referenceable', 'Statement', 'ValueClause', 'WhenCondition'];
    }
    computeIsSubtype(subtype, supertype) {
        switch (subtype) {
            case AndExpression:
            case Group:
            case Negation:
            case OrExpression:
            case Statement: {
                return this.isSubtype(PropositionalExpression, supertype);
            }
            case Condition:
            case Proposition: {
                return this.isSubtype(Referenceable, supertype);
            }
            default: {
                return false;
            }
        }
    }
    getReferenceType(refInfo) {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'RaisingConcern:concern': {
                return Concern;
            }
            case 'Statement:reference': {
                return Referenceable;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
    getTypeMetaData(type) {
        switch (type) {
            case 'DisableClause': {
                return {
                    name: 'DisableClause',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'LaboratoryInformation': {
                return {
                    name: 'LaboratoryInformation',
                    mandatory: [
                        { name: 'descriptions', type: 'array' },
                        { name: 'icons', type: 'array' },
                        { name: 'titles', type: 'array' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    mandatory: [
                        { name: 'concerns', type: 'array' },
                        { name: 'conditions', type: 'array' },
                        { name: 'propositions', type: 'array' }
                    ]
                };
            }
            case 'Proposition': {
                return {
                    name: 'Proposition',
                    mandatory: [
                        { name: 'valueClauses', type: 'array' }
                    ]
                };
            }
            case 'Statement': {
                return {
                    name: 'Statement',
                    mandatory: [
                        { name: 'negation', type: 'boolean' },
                        { name: 'value', type: 'boolean' }
                    ]
                };
            }
            case 'ValueClause': {
                return {
                    name: 'ValueClause',
                    mandatory: [
                        { name: 'default', type: 'boolean' },
                        { name: 'raises', type: 'array' },
                        { name: 'value', type: 'boolean' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}
export const reflection = new JavaScriptPropositionalLaboratoryFormatAstReflection();
//# sourceMappingURL=ast.js.map