/******************************************************************************
 * This file was generated by langium-cli 2.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/
import { AbstractAstReflection } from '../../syntax-tree.js';
export const LangiumGrammarTerminals = {
    ID: /\^?[_a-zA-Z][\w_]*/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    RegexLiteral: /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\/[a-z]*/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};
export const AbstractRule = 'AbstractRule';
export function isAbstractRule(item) {
    return reflection.isInstance(item, AbstractRule);
}
export const AbstractType = 'AbstractType';
export function isAbstractType(item) {
    return reflection.isInstance(item, AbstractType);
}
export const Condition = 'Condition';
export function isCondition(item) {
    return reflection.isInstance(item, Condition);
}
export function isFeatureName(item) {
    return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\^?[_a-zA-Z][\w_]*/.test(item)));
}
export function isPrimitiveType(item) {
    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';
}
export const TypeDefinition = 'TypeDefinition';
export function isTypeDefinition(item) {
    return reflection.isInstance(item, TypeDefinition);
}
export const AbstractElement = 'AbstractElement';
export function isAbstractElement(item) {
    return reflection.isInstance(item, AbstractElement);
}
export const ArrayType = 'ArrayType';
export function isArrayType(item) {
    return reflection.isInstance(item, ArrayType);
}
export const Conjunction = 'Conjunction';
export function isConjunction(item) {
    return reflection.isInstance(item, Conjunction);
}
export const Disjunction = 'Disjunction';
export function isDisjunction(item) {
    return reflection.isInstance(item, Disjunction);
}
export const Grammar = 'Grammar';
export function isGrammar(item) {
    return reflection.isInstance(item, Grammar);
}
export const GrammarImport = 'GrammarImport';
export function isGrammarImport(item) {
    return reflection.isInstance(item, GrammarImport);
}
export const InferredType = 'InferredType';
export function isInferredType(item) {
    return reflection.isInstance(item, InferredType);
}
export const Interface = 'Interface';
export function isInterface(item) {
    return reflection.isInstance(item, Interface);
}
export const LiteralCondition = 'LiteralCondition';
export function isLiteralCondition(item) {
    return reflection.isInstance(item, LiteralCondition);
}
export const NamedArgument = 'NamedArgument';
export function isNamedArgument(item) {
    return reflection.isInstance(item, NamedArgument);
}
export const Negation = 'Negation';
export function isNegation(item) {
    return reflection.isInstance(item, Negation);
}
export const Parameter = 'Parameter';
export function isParameter(item) {
    return reflection.isInstance(item, Parameter);
}
export const ParameterReference = 'ParameterReference';
export function isParameterReference(item) {
    return reflection.isInstance(item, ParameterReference);
}
export const ParserRule = 'ParserRule';
export function isParserRule(item) {
    return reflection.isInstance(item, ParserRule);
}
export const ReferenceType = 'ReferenceType';
export function isReferenceType(item) {
    return reflection.isInstance(item, ReferenceType);
}
export const ReturnType = 'ReturnType';
export function isReturnType(item) {
    return reflection.isInstance(item, ReturnType);
}
export const SimpleType = 'SimpleType';
export function isSimpleType(item) {
    return reflection.isInstance(item, SimpleType);
}
export const TerminalRule = 'TerminalRule';
export function isTerminalRule(item) {
    return reflection.isInstance(item, TerminalRule);
}
export const Type = 'Type';
export function isType(item) {
    return reflection.isInstance(item, Type);
}
export const TypeAttribute = 'TypeAttribute';
export function isTypeAttribute(item) {
    return reflection.isInstance(item, TypeAttribute);
}
export const UnionType = 'UnionType';
export function isUnionType(item) {
    return reflection.isInstance(item, UnionType);
}
export const Action = 'Action';
export function isAction(item) {
    return reflection.isInstance(item, Action);
}
export const Alternatives = 'Alternatives';
export function isAlternatives(item) {
    return reflection.isInstance(item, Alternatives);
}
export const Assignment = 'Assignment';
export function isAssignment(item) {
    return reflection.isInstance(item, Assignment);
}
export const CharacterRange = 'CharacterRange';
export function isCharacterRange(item) {
    return reflection.isInstance(item, CharacterRange);
}
export const CrossReference = 'CrossReference';
export function isCrossReference(item) {
    return reflection.isInstance(item, CrossReference);
}
export const EndOfFile = 'EndOfFile';
export function isEndOfFile(item) {
    return reflection.isInstance(item, EndOfFile);
}
export const Group = 'Group';
export function isGroup(item) {
    return reflection.isInstance(item, Group);
}
export const Keyword = 'Keyword';
export function isKeyword(item) {
    return reflection.isInstance(item, Keyword);
}
export const NegatedToken = 'NegatedToken';
export function isNegatedToken(item) {
    return reflection.isInstance(item, NegatedToken);
}
export const RegexToken = 'RegexToken';
export function isRegexToken(item) {
    return reflection.isInstance(item, RegexToken);
}
export const RuleCall = 'RuleCall';
export function isRuleCall(item) {
    return reflection.isInstance(item, RuleCall);
}
export const TerminalAlternatives = 'TerminalAlternatives';
export function isTerminalAlternatives(item) {
    return reflection.isInstance(item, TerminalAlternatives);
}
export const TerminalGroup = 'TerminalGroup';
export function isTerminalGroup(item) {
    return reflection.isInstance(item, TerminalGroup);
}
export const TerminalRuleCall = 'TerminalRuleCall';
export function isTerminalRuleCall(item) {
    return reflection.isInstance(item, TerminalRuleCall);
}
export const UnorderedGroup = 'UnorderedGroup';
export function isUnorderedGroup(item) {
    return reflection.isInstance(item, UnorderedGroup);
}
export const UntilToken = 'UntilToken';
export function isUntilToken(item) {
    return reflection.isInstance(item, UntilToken);
}
export const Wildcard = 'Wildcard';
export function isWildcard(item) {
    return reflection.isInstance(item, Wildcard);
}
export class LangiumGrammarAstReflection extends AbstractAstReflection {
    getAllTypes() {
        return ['AbstractElement', 'AbstractRule', 'AbstractType', 'Action', 'Alternatives', 'ArrayType', 'Assignment', 'CharacterRange', 'Condition', 'Conjunction', 'CrossReference', 'Disjunction', 'EndOfFile', 'Grammar', 'GrammarImport', 'Group', 'InferredType', 'Interface', 'Keyword', 'LiteralCondition', 'NamedArgument', 'NegatedToken', 'Negation', 'Parameter', 'ParameterReference', 'ParserRule', 'ReferenceType', 'RegexToken', 'ReturnType', 'RuleCall', 'SimpleType', 'TerminalAlternatives', 'TerminalGroup', 'TerminalRule', 'TerminalRuleCall', 'Type', 'TypeAttribute', 'TypeDefinition', 'UnionType', 'UnorderedGroup', 'UntilToken', 'Wildcard'];
    }
    computeIsSubtype(subtype, supertype) {
        switch (subtype) {
            case Action: {
                return this.isSubtype(AbstractElement, supertype) || this.isSubtype(AbstractType, supertype);
            }
            case Alternatives:
            case Assignment:
            case CharacterRange:
            case CrossReference:
            case EndOfFile:
            case Group:
            case Keyword:
            case NegatedToken:
            case RegexToken:
            case RuleCall:
            case TerminalAlternatives:
            case TerminalGroup:
            case TerminalRuleCall:
            case UnorderedGroup:
            case UntilToken:
            case Wildcard: {
                return this.isSubtype(AbstractElement, supertype);
            }
            case ArrayType:
            case ReferenceType:
            case SimpleType:
            case UnionType: {
                return this.isSubtype(TypeDefinition, supertype);
            }
            case Conjunction:
            case Disjunction:
            case LiteralCondition:
            case Negation:
            case ParameterReference: {
                return this.isSubtype(Condition, supertype);
            }
            case Interface:
            case Type: {
                return this.isSubtype(AbstractType, supertype);
            }
            case ParserRule: {
                return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);
            }
            case TerminalRule: {
                return this.isSubtype(AbstractRule, supertype);
            }
            default: {
                return false;
            }
        }
    }
    getReferenceType(refInfo) {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Action:type':
            case 'CrossReference:type':
            case 'Interface:superTypes':
            case 'ParserRule:returnType':
            case 'SimpleType:typeRef': {
                return AbstractType;
            }
            case 'Grammar:hiddenTokens':
            case 'ParserRule:hiddenTokens':
            case 'RuleCall:rule': {
                return AbstractRule;
            }
            case 'Grammar:usedGrammars': {
                return Grammar;
            }
            case 'NamedArgument:parameter':
            case 'ParameterReference:parameter': {
                return Parameter;
            }
            case 'TerminalRuleCall:rule': {
                return TerminalRule;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
    getTypeMetaData(type) {
        switch (type) {
            case 'Grammar': {
                return {
                    name: 'Grammar',
                    mandatory: [
                        { name: 'definesHiddenTokens', type: 'boolean' },
                        { name: 'hiddenTokens', type: 'array' },
                        { name: 'imports', type: 'array' },
                        { name: 'interfaces', type: 'array' },
                        { name: 'isDeclared', type: 'boolean' },
                        { name: 'rules', type: 'array' },
                        { name: 'types', type: 'array' },
                        { name: 'usedGrammars', type: 'array' }
                    ]
                };
            }
            case 'Interface': {
                return {
                    name: 'Interface',
                    mandatory: [
                        { name: 'attributes', type: 'array' },
                        { name: 'superTypes', type: 'array' }
                    ]
                };
            }
            case 'LiteralCondition': {
                return {
                    name: 'LiteralCondition',
                    mandatory: [
                        { name: 'true', type: 'boolean' }
                    ]
                };
            }
            case 'NamedArgument': {
                return {
                    name: 'NamedArgument',
                    mandatory: [
                        { name: 'calledByName', type: 'boolean' }
                    ]
                };
            }
            case 'ParserRule': {
                return {
                    name: 'ParserRule',
                    mandatory: [
                        { name: 'definesHiddenTokens', type: 'boolean' },
                        { name: 'entry', type: 'boolean' },
                        { name: 'fragment', type: 'boolean' },
                        { name: 'hiddenTokens', type: 'array' },
                        { name: 'parameters', type: 'array' },
                        { name: 'wildcard', type: 'boolean' }
                    ]
                };
            }
            case 'TerminalRule': {
                return {
                    name: 'TerminalRule',
                    mandatory: [
                        { name: 'fragment', type: 'boolean' },
                        { name: 'hidden', type: 'boolean' }
                    ]
                };
            }
            case 'TypeAttribute': {
                return {
                    name: 'TypeAttribute',
                    mandatory: [
                        { name: 'isOptional', type: 'boolean' }
                    ]
                };
            }
            case 'UnionType': {
                return {
                    name: 'UnionType',
                    mandatory: [
                        { name: 'types', type: 'array' }
                    ]
                };
            }
            case 'Alternatives': {
                return {
                    name: 'Alternatives',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'CrossReference': {
                return {
                    name: 'CrossReference',
                    mandatory: [
                        { name: 'deprecatedSyntax', type: 'boolean' }
                    ]
                };
            }
            case 'Group': {
                return {
                    name: 'Group',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'RuleCall': {
                return {
                    name: 'RuleCall',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'TerminalAlternatives': {
                return {
                    name: 'TerminalAlternatives',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'TerminalGroup': {
                return {
                    name: 'TerminalGroup',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'UnorderedGroup': {
                return {
                    name: 'UnorderedGroup',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}
export const reflection = new LangiumGrammarAstReflection();
//# sourceMappingURL=ast.js.map