import { createServicesForGrammar, getDocument, GrammarAST, prepareLangiumParser } from 'langium';
import { getFilePath } from './package.js';
export async function validateParser(grammar, config, grammarConfigMap, grammarServices) {
    var _a;
    const parserConfig = Object.assign(Object.assign(Object.assign({}, config.chevrotainParserConfig), (_a = grammarConfigMap.get(grammar)) === null || _a === void 0 ? void 0 : _a.chevrotainParserConfig), { skipValidations: false });
    const services = await createServicesForGrammar({
        grammarServices,
        grammar,
        languageMetaData: languageConfigToMetaData(grammarConfigMap.get(grammar)),
        parserConfig
    });
    let parser;
    try {
        parser = prepareLangiumParser(services);
        // The finalization step invokes parser validation, which can lead to thrown errors
        parser.finalize();
        return undefined;
    }
    catch (err) {
        if (parser && parser.definitionErrors.length > 0) {
            // Construct a message with tracing information
            let message = 'Parser definition errors detected:';
            for (const defError of parser.definitionErrors) {
                message += '\n-------------------------------\n';
                if (defError.ruleName) {
                    const rule = findRule(defError.ruleName, grammar, grammarServices.shared.workspace.LangiumDocuments);
                    if (rule && rule.$cstNode) {
                        const filePath = getFilePath(getDocument(rule).uri.fsPath, config);
                        const line = rule.$cstNode.range.start.line + 1;
                        message += `${filePath}:${line} - `;
                    }
                }
                message += defError.message;
            }
            return new Error(message);
        }
        if (err instanceof Error) {
            return err;
        }
        throw err;
    }
}
function languageConfigToMetaData(config) {
    var _a;
    return {
        languageId: config.id,
        fileExtensions: (_a = config.fileExtensions) !== null && _a !== void 0 ? _a : [],
        caseInsensitive: Boolean(config.caseInsensitive)
    };
}
function findRule(name, grammar, documents) {
    for (const rule of grammar.rules) {
        if (rule.name === name && GrammarAST.isParserRule(rule)) {
            return rule;
        }
    }
    for (const document of documents.all) {
        const ast = document.parseResult.value;
        if (GrammarAST.isGrammar(ast)) {
            for (const rule of ast.rules) {
                if (rule.name === name && GrammarAST.isParserRule(rule)) {
                    return rule;
                }
            }
        }
    }
    return undefined;
}
//# sourceMappingURL=parser-validation.js.map