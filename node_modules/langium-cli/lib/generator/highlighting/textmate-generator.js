import { EOL, escapeRegExp, getCaseInsensitivePattern, getTerminalParts, GrammarAST, isCommentTerminal, stream } from 'langium';
import { terminalRegex } from 'langium/internal';
import { collectKeywords } from '../util.js';
export function generateTextMate(grammar, config) {
    var _a;
    const json = {
        name: config.id,
        scopeName: `source.${config.id}`,
        fileTypes: (_a = config.fileExtensions) !== null && _a !== void 0 ? _a : [],
        patterns: getPatterns(grammar, config),
        repository: getRepository(grammar, config)
    };
    return JSON.stringify(json, null, 2) + EOL;
}
function getPatterns(grammar, config) {
    const patterns = [];
    patterns.push({
        include: '#comments'
    });
    patterns.push(getControlKeywords(grammar, config));
    patterns.push(...getStringPatterns(grammar, config));
    return patterns;
}
function getRepository(grammar, config) {
    const repository = {};
    const commentPatterns = [];
    let stringEscapePattern;
    for (const rule of grammar.rules) {
        if (GrammarAST.isTerminalRule(rule) && isCommentTerminal(rule)) {
            const parts = getTerminalParts(terminalRegex(rule));
            for (const part of parts) {
                if (part.end) {
                    commentPatterns.push({
                        'name': `comment.block.${config.id}`,
                        'begin': part.start,
                        'beginCaptures': {
                            '0': {
                                'name': `punctuation.definition.comment.${config.id}`
                            }
                        },
                        'end': part.end,
                        'endCaptures': {
                            '0': {
                                'name': `punctuation.definition.comment.${config.id}`
                            }
                        }
                    });
                }
                else {
                    commentPatterns.push({
                        'begin': part.start,
                        'beginCaptures': {
                            '1': {
                                'name': `punctuation.whitespace.comment.leading.${config.id}`
                            }
                        },
                        'end': '(?=$)',
                        'name': `comment.line.${config.id}`
                    });
                }
            }
        }
        else if (GrammarAST.isTerminalRule(rule) && rule.name.toLowerCase() === 'string') {
            stringEscapePattern = {
                'name': `constant.character.escape.${config.id}`,
                'match': '\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|u\\{[0-9A-Fa-f]+\\}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.|$)'
            };
        }
    }
    if (commentPatterns.length > 0) {
        repository['comments'] = {
            'patterns': commentPatterns
        };
    }
    if (stringEscapePattern) {
        repository['string-character-escape'] = stringEscapePattern;
    }
    return repository;
}
function getControlKeywords(grammar, pack) {
    const regex = /[A-Za-z]/;
    const controlKeywords = collectKeywords(grammar).filter(kw => regex.test(kw));
    const groups = groupKeywords(controlKeywords, pack.caseInsensitive);
    return {
        'name': `keyword.control.${pack.id}`,
        'match': groups.join('|')
    };
}
function groupKeywords(keywords, caseInsensitive) {
    const groups = { letter: [], leftSpecial: [], rightSpecial: [], special: [] };
    keywords.forEach(keyword => {
        const keywordPattern = caseInsensitive ? getCaseInsensitivePattern(keyword) : escapeRegExp(keyword);
        if (/\w/.test(keyword[0])) {
            if (/\w/.test(keyword[keyword.length - 1])) {
                groups.letter.push(keywordPattern);
            }
            else {
                groups.rightSpecial.push(keywordPattern);
            }
        }
        else {
            if ((/\w/).test(keyword[keyword.length - 1])) {
                groups.leftSpecial.push(keywordPattern);
            }
            else {
                groups.special.push(keywordPattern);
            }
        }
    });
    const res = [];
    if (groups.letter.length)
        res.push(`\\b(${groups.letter.join('|')})\\b`);
    if (groups.leftSpecial.length)
        res.push(`\\B(${groups.leftSpecial.join('|')})\\b`);
    if (groups.rightSpecial.length)
        res.push(`\\b(${groups.rightSpecial.join('|')})\\B`);
    if (groups.special.length)
        res.push(`\\B(${groups.special.join('|')})\\B`);
    return res;
}
function getStringPatterns(grammar, pack) {
    const terminals = stream(grammar.rules).filter(GrammarAST.isTerminalRule);
    const stringTerminal = terminals.find(e => e.name.toLowerCase() === 'string');
    const stringPatterns = [];
    if (stringTerminal) {
        const parts = getTerminalParts(terminalRegex(stringTerminal));
        for (const part of parts) {
            if (part.end) {
                stringPatterns.push({
                    'name': `string.quoted.${delimiterName(part.start)}.${pack.id}`,
                    'begin': part.start,
                    'end': part.end,
                    'patterns': [
                        {
                            'include': '#string-character-escape'
                        }
                    ]
                });
            }
        }
    }
    return stringPatterns;
}
function delimiterName(delimiter) {
    if (delimiter === "'") {
        return 'single';
    }
    else if (delimiter === '"') {
        return 'double';
    }
    else if (delimiter === '`') {
        return 'backtick';
    }
    else {
        return 'delimiter';
    }
}
//# sourceMappingURL=textmate-generator.js.map